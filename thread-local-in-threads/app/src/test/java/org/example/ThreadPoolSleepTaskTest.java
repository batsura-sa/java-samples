/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;

class ThreadPoolSleepTaskTest {
    private static final int MAX_TASKS = 100;

    @Test
    void threadLocalWorksFineForNewStealingPool() throws Exception {
        taskRunner("newWorkStealingPool", Executors.newWorkStealingPool(), false);
    }

    @Test
    void threadLocalWorksFineForNewCachedThreadPool() throws Exception {
        taskRunner("newCachedThreadPool", Executors.newCachedThreadPool(), false);
    }

    @Test
    void threadLocalWorksFineForNewFixedThreadPool() throws Exception {
        taskRunner("newFixedThreadPool", Executors.newFixedThreadPool(10), false);
    }

    @Test
    void threadLocalWorksFineForVirtualThreadPool() throws Exception {
        taskRunner("newVirtualThreadPerTaskExecutor", Executors.newVirtualThreadPerTaskExecutor(), true);
    }

    private void taskRunner(String executorName, ExecutorService executor, boolean isVirtual) throws Exception {
        System.out.println("Running " + MAX_TASKS + " tasks using " + executorName);
        long before = System.currentTimeMillis();
        try (executor) {
            Map<Integer, Future<SleepTask.Info>> numbers = new HashMap<>();
            for (int i = 0; i < MAX_TASKS; i++) {
                numbers.put(i, executor.submit(new SleepTask(i)));
            }
            for (var entry : numbers.entrySet()) {
                Integer number = entry.getKey();
                SleepTask.Info info = entry.getValue().get();
                assertEquals(number, info.number(), info.toString());
                assertEquals(isVirtual, info.isVirtual(), info.toString());
            }
        }
        long after = System.currentTimeMillis();
        System.out.println(executorName + " time: " + (after - before));
    }
}